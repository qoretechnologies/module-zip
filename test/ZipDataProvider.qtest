#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

/*
    Qore ZipDataProvider module test suite

    Copyright (C) 2026 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

%new-style
%strict-args
%require-types
%enable-all-warnings

%requires QUnit
%requires Util
%requires DataProvider
%requires zip
%requires ZipDataProvider

%exec-class ZipDataProviderTest

public class ZipDataProviderTest inherits QUnit::Test {
    private {
        string testDir;
    }

    constructor() : Test("ZipDataProviderTest", "1.0") {
        testDir = tmp_location() + "/zip_dp_test_" + string(getpid());

        addTestCase("Module loading tests", \moduleLoadingTest());
        addTestCase("App registration tests", \appRegistrationTest());
        addTestCase("Integration tests", \integrationTest());
        addTestCase("Compression tests", \compressionTest());
        addTestCase("Create archive action tests", \createArchiveActionTest());
        addTestCase("Extract archive action tests", \extractArchiveActionTest());
        addTestCase("List archive action tests", \listArchiveActionTest());
        addTestCase("Archive info action tests", \archiveInfoActionTest());
        addTestCase("Add files action tests", \addFilesActionTest());
        addTestCase("Extract file action tests", \extractFileActionTest());
        addTestCase("Compress data action tests", \compressDataActionTest());
        addTestCase("Decompress data action tests", \decompressDataActionTest());

        set_return_value(main());
    }

    setUp() {
        mkdir(testDir, 0755);
    }

    tearDown() {
        if (is_dir(testDir)) {
            system("rm -rf " + testDir);
        }
    }

    # ==================== Module Loading Tests ====================

    moduleLoadingTest() {
        # Test that ZipDataProvider module loads successfully
        assertEq(True, True, "ZipDataProvider module loaded");

        # Test that the factory is registered
        AbstractDataProviderFactory zipFactory = DataProvider::getFactory("zip");
        assertEq(True, exists zipFactory, "zip factory is registered");
        assertEq("zip", zipFactory.getName(), "factory name is 'zip'");
    }

    # ==================== App Registration Tests ====================

    appRegistrationTest() {
        # Test app registration
        *hash<DataProviderAppInfo> appInfo = DataProviderActionCatalog::getApp("Zip");
        assertEq(True, exists appInfo, "Zip app is registered");
        assertEq("Zip", appInfo.name, "app name is Zip");
        assertEq("Zip Archive", appInfo.display_name, "app display_name");
        assertEq(True, exists appInfo.short_desc, "app has short_desc");
        assertEq(True, exists appInfo.desc, "app has desc");
        assertEq(True, exists appInfo.logo, "app has logo");
        assertEq("zip-logo.svg", appInfo.logo_file_name, "app logo_file_name");
        assertEq(MimeTypeSvg, appInfo.logo_mime_type, "app logo_mime_type");

        # Verify logo is valid SVG
        assertEq(True, appInfo.logo.find("<svg") >= 0, "logo contains SVG tag");
        assertEq(True, appInfo.logo.find("</svg>") >= 0, "logo contains closing SVG tag");
    }

    # ==================== Integration Tests ====================

    integrationTest() {
        # Full workflow test: create -> list -> extract -> verify

        string zipPath = testDir + "/dp_integration.zip";
        string extractDir = testDir + "/dp_integration_extracted";
        mkdir(extractDir);

        # Step 1: Create archive using ZipFile
        {
            ZipFile zip(zipPath, "w");
            zip.addText("readme.txt", "Integration test readme");
            zip.addText("data/config.json", '{"setting": "value"}');
            zip.addText("data/users.csv", "id,name\n1,Alice\n2,Bob");
            zip.setComment("Integration test archive");
            zip.close();
        }

        # Step 2: Verify archive was created
        assertEq(True, is_file(zipPath), "archive file exists");

        # Step 3: List contents
        {
            ZipFile zip(zipPath, "r");
            list<hash<ZipEntryInfo>> entries = zip.entries();
            assertEq(3, entries.size(), "integration archive has 3 entries");

            # Verify entry names
            hash<string, bool> entryNames;
            foreach hash<ZipEntryInfo> entry in (entries) {
                entryNames{entry.name} = True;
            }
            assertEq(True, exists entryNames{"readme.txt"}, "has readme.txt");
            assertEq(True, exists entryNames{"data/config.json"}, "has data/config.json");
            assertEq(True, exists entryNames{"data/users.csv"}, "has data/users.csv");
            zip.close();
        }

        # Step 4: Extract archive
        {
            ZipFile zip(zipPath, "r");
            zip.extractAll(extractDir);
            zip.close();
        }

        # Step 5: Verify extraction
        assertEq(True, is_file(extractDir + "/readme.txt"), "readme.txt extracted");
        assertEq(True, is_file(extractDir + "/data/config.json"), "data/config.json extracted");
        assertEq(True, is_file(extractDir + "/data/users.csv"), "data/users.csv extracted");

        # Verify content
        string readmeContent = ReadOnlyFile::readTextFile(extractDir + "/readme.txt");
        assertEq("Integration test readme", readmeContent, "readme content matches");

        string jsonContent = ReadOnlyFile::readTextFile(extractDir + "/data/config.json");
        assertEq('{"setting": "value"}', jsonContent, "json content matches");

        # Step 6: Create in-memory archive and decompress
        binary memArchive;
        {
            ZipFile zip();
            zip.addText("memory1.txt", "Memory content 1");
            zip.addText("memory2.txt", "Memory content 2");
            memArchive = zip.toData();
        }

        assertEq(True, memArchive.size() > 0, "in-memory archive created");

        # Verify in-memory archive contents
        {
            ZipFile zip(memArchive);
            assertEq(2, zip.count(), "memory archive has 2 entries");
            string content1 = zip.readText("memory1.txt");
            assertEq("Memory content 1", content1, "memory1 content matches");
            zip.close();
        }
    }

    # ==================== Compression Tests ====================

    compressionTest() {
        # Test compression with data provider workflow
        string largeContent = strmul("This is test content for compression testing. ", 1000);
        binary compressedArchive;
        {
            ZipFile zip();
            zip.addText("large.txt", largeContent, NOTHING, <ZipAddOptions>{
                "compression_method": ZIP_CM_DEFLATE,
                "compression_level": ZIP_COMPRESSION_BEST,
            });
            compressedArchive = zip.toData();
        }

        # Verify compression worked (archive should be smaller than content)
        assertEq(True, compressedArchive.size() < largeContent.size(), "compression reduced size");

        # Verify content integrity
        {
            ZipFile zip(compressedArchive);
            string decompressed = zip.readText("large.txt");
            assertEq(largeContent, decompressed, "decompressed content matches original");
            zip.close();
        }
    }

    # ==================== Create Archive Action Tests ====================

    createArchiveActionTest() {
        # Get the create archive data provider using factory path
        ZipDataProvider factory();
        AbstractDataProvider dp = factory.getChildProviderEx("archive").getChildProviderEx("create");
        assertEq(True, exists dp, "create archive provider exists");
        assertEq("create", dp.getName(), "provider name is 'create'");

        # Test creating archive to file
        {
            string zipPath = testDir + "/dp_create_file.zip";
            hash<auto> request = {
                "output_path": zipPath,
                "entries": (
                    {"name": "file1.txt", "data": binary("Content 1")},
                    {"name": "file2.txt", "data": binary("Content 2")},
                ),
                "comment": "Test archive",
            };

            hash<auto> response = dp.doRequest(request);
            assertEq(True, response.success, "create file archive succeeded");
            assertEq(2, response.entry_count, "entry count is 2");
            assertEq(zipPath, response.output_path, "output path matches");
            assertEq(True, response.size > 0, "archive has size");
            assertEq(True, is_file(zipPath), "archive file exists");

            # Verify contents
            ZipFile zip(zipPath, "r");
            assertEq(2, zip.count(), "archive has 2 entries");
            assertEq("Content 1", zip.readText("file1.txt"), "file1 content matches");
            zip.close();
        }

        # Test creating in-memory archive
        {
            hash<auto> request = {
                "entries": (
                    {"name": "mem1.txt", "data": binary("Memory content")},
                ),
            };

            hash<auto> response = dp.doRequest(request);
            assertEq(True, response.success, "create memory archive succeeded");
            assertEq(1, response.entry_count, "entry count is 1");
            assertEq(True, exists response.data, "response has data");
            assertEq(True, response.data.size() > 0, "data has content");

            # Verify contents
            ZipFile zip(response.data);
            assertEq("Memory content", zip.readText("mem1.txt"), "memory content matches");
            zip.close();
        }
    }

    # ==================== Extract Archive Action Tests ====================

    extractArchiveActionTest() {
        # Create test archive first
        string zipPath = testDir + "/dp_extract_test.zip";
        {
            ZipFile zip(zipPath, "w");
            zip.addText("extract1.txt", "Extract content 1");
            zip.addText("subdir/extract2.txt", "Extract content 2");
            zip.close();
        }

        # Get the extract archive data provider
        ZipDataProvider factory();
        AbstractDataProvider dp = factory.getChildProviderEx("archive").getChildProviderEx("extract");
        assertEq(True, exists dp, "extract archive provider exists");

        # Test extracting from file
        {
            string extractDir = testDir + "/dp_extracted";
            mkdir(extractDir);

            hash<auto> request = {
                "input_path": zipPath,
                "destination": extractDir,
            };

            hash<auto> response = dp.doRequest(request);
            assertEq(True, response.success, "extract succeeded");
            assertEq(2, response.entry_count, "entry count is 2");
            assertEq(extractDir, response.destination, "destination matches");
            assertEq(True, response.extracted_files.size() > 0, "has extracted files list");

            # Verify extraction
            assertEq(True, is_file(extractDir + "/extract1.txt"), "extract1.txt exists");
            assertEq(True, is_file(extractDir + "/subdir/extract2.txt"), "subdir/extract2.txt exists");
            assertEq("Extract content 1", ReadOnlyFile::readTextFile(extractDir + "/extract1.txt"), "content matches");
        }

        # Test extracting from binary data
        {
            binary archiveData = File::readBinaryFile(zipPath);
            string extractDir2 = testDir + "/dp_extracted2";
            mkdir(extractDir2);

            hash<auto> request = {
                "data": archiveData,
                "destination": extractDir2,
            };

            hash<auto> response = dp.doRequest(request);
            assertEq(True, response.success, "extract from binary succeeded");
            assertEq(True, is_file(extractDir2 + "/extract1.txt"), "file extracted from binary");
        }
    }

    # ==================== List Archive Action Tests ====================

    listArchiveActionTest() {
        # Create test archive
        string zipPath = testDir + "/dp_list_test.zip";
        {
            ZipFile zip(zipPath, "w");
            zip.addText("list1.txt", "List content 1");
            zip.addText("list2.txt", "List content 2");
            zip.addDirectory("emptydir/");
            zip.close();
        }

        # Get the list archive data provider
        ZipDataProvider factory();
        AbstractDataProvider dp = factory.getChildProviderEx("archive").getChildProviderEx("list");
        assertEq(True, exists dp, "list archive provider exists");

        # Test listing from file
        {
            hash<auto> request = {
                "input_path": zipPath,
            };

            hash<auto> response = dp.doRequest(request);
            assertEq(3, response.count, "count is 3");
            assertEq(3, response.entries.size(), "entries list has 3 items");

            # Check entry details
            hash<string, hash<ZipEntryInfo>> entriesByName;
            foreach hash<ZipEntryInfo> entry in (response.entries) {
                entriesByName{entry.name} = entry;
            }
            assertEq(True, exists entriesByName{"list1.txt"}, "has list1.txt");
            assertEq(True, exists entriesByName{"list2.txt"}, "has list2.txt");
            assertEq(True, exists entriesByName{"emptydir/"}, "has emptydir/");
            assertEq(True, entriesByName{"emptydir/"}.is_directory, "emptydir is directory");
        }

        # Test listing from binary data
        {
            binary archiveData = File::readBinaryFile(zipPath);
            hash<auto> request = {
                "data": archiveData,
            };

            hash<auto> response = dp.doRequest(request);
            assertEq(3, response.count, "count from binary is 3");
        }
    }

    # ==================== Archive Info Action Tests ====================

    archiveInfoActionTest() {
        # Create test archive with comment
        string zipPath = testDir + "/dp_info_test.zip";
        {
            ZipFile zip(zipPath, "w");
            zip.addText("info1.txt", "Info content 1");
            zip.addText("info2.txt", strmul("Large content ", 100));
            zip.setComment("Test archive comment");
            zip.close();
        }

        # Get the archive info data provider
        ZipDataProvider factory();
        AbstractDataProvider dp = factory.getChildProviderEx("archive").getChildProviderEx("info");
        assertEq(True, exists dp, "archive info provider exists");

        # Test getting info
        {
            hash<auto> request = {
                "input_path": zipPath,
            };

            hash<auto> response = dp.doRequest(request);
            assertEq(zipPath, response.path, "path matches");
            assertEq(2, response.entry_count, "entry count is 2");
            assertEq(True, response.total_size > 0, "has total size");
            assertEq(True, response.compressed_size > 0, "has compressed size");
            assertEq("Test archive comment", response.comment, "comment matches");
        }
    }

    # ==================== Add Files Action Tests ====================

    addFilesActionTest() {
        # Create initial archive
        string zipPath = testDir + "/dp_add_test.zip";
        {
            ZipFile zip(zipPath, "w");
            zip.addText("original.txt", "Original content");
            zip.close();
        }

        # Get the add files data provider
        ZipDataProvider factory();
        AbstractDataProvider dp = factory.getChildProviderEx("archive").getChildProviderEx("add");
        assertEq(True, exists dp, "add files provider exists");

        # Test adding files
        {
            hash<auto> request = {
                "archive_path": zipPath,
                "entries": (
                    {"name": "added1.txt", "data": binary("Added content 1")},
                    {"name": "added2.txt", "data": binary("Added content 2")},
                ),
            };

            hash<auto> response = dp.doRequest(request);
            assertEq(True, response.success, "add files succeeded");
            assertEq(2, response.entries_added, "2 entries added");

            # Verify archive now has all files
            ZipFile zip(zipPath, "r");
            assertEq(3, zip.count(), "archive now has 3 entries");
            assertEq(True, zip.hasEntry("original.txt"), "original still exists");
            assertEq(True, zip.hasEntry("added1.txt"), "added1 exists");
            assertEq(True, zip.hasEntry("added2.txt"), "added2 exists");
            zip.close();
        }
    }

    # ==================== Extract File Action Tests ====================

    extractFileActionTest() {
        # Create test archive
        string zipPath = testDir + "/dp_extract_file_test.zip";
        {
            ZipFile zip(zipPath, "w");
            zip.addText("single.txt", "Single file content");
            zip.addText("other.txt", "Other content");
            zip.close();
        }

        # Get the extract file data provider
        ZipDataProvider factory();
        AbstractDataProvider dp = factory.getChildProviderEx("file").getChildProviderEx("extract");
        assertEq(True, exists dp, "extract file provider exists");

        # Test extracting to memory
        {
            hash<auto> request = {
                "archive_path": zipPath,
                "entry_name": "single.txt",
            };

            hash<auto> response = dp.doRequest(request);
            assertEq(True, response.success, "extract to memory succeeded");
            assertEq("single.txt", response.entry_name, "entry name matches");
            assertEq(True, exists response.data, "response has data");
            assertEq("Single file content", response.data.toString("UTF-8"), "content matches");
            assertEq(True, response.size > 0, "has size");
        }

        # Test extracting to file
        {
            string outputPath = testDir + "/dp_single_extracted.txt";
            hash<auto> request = {
                "archive_path": zipPath,
                "entry_name": "single.txt",
                "output_path": outputPath,
            };

            hash<auto> response = dp.doRequest(request);
            assertEq(True, response.success, "extract to file succeeded");
            assertEq(outputPath, response.output_path, "output path matches");
            assertEq(True, is_file(outputPath), "output file exists");
            assertEq("Single file content", ReadOnlyFile::readTextFile(outputPath), "file content matches");
        }

        # Test extracting from binary archive
        {
            binary archiveData = File::readBinaryFile(zipPath);
            hash<auto> request = {
                "archive_data": archiveData,
                "entry_name": "other.txt",
            };

            hash<auto> response = dp.doRequest(request);
            assertEq(True, response.success, "extract from binary succeeded");
            assertEq("Other content", response.data.toString("UTF-8"), "content from binary matches");
        }
    }

    # ==================== Compress Data Action Tests ====================

    compressDataActionTest() {
        # Get the compress data provider
        ZipDataProvider factory();
        AbstractDataProvider dp = factory.getChildProviderEx("data").getChildProviderEx("compress");
        assertEq(True, exists dp, "compress data provider exists");

        # Test compressing data
        {
            hash<auto> request = {
                "entries": (
                    {"name": "compress1.txt", "data": binary("Compress content 1")},
                    {"name": "compress2.txt", "data": binary("Compress content 2")},
                ),
                "compression_method": ZIP_CM_DEFLATE,
            };

            hash<auto> response = dp.doRequest(request);
            assertEq(True, exists response.data, "response has data");
            assertEq(2, response.entry_count, "entry count is 2");
            assertEq(True, response.size > 0, "has size");

            # Verify the compressed data is valid
            ZipFile zip(response.data);
            assertEq(2, zip.count(), "compressed archive has 2 entries");
            assertEq("Compress content 1", zip.readText("compress1.txt"), "content 1 matches");
            assertEq("Compress content 2", zip.readText("compress2.txt"), "content 2 matches");
            zip.close();
        }

        # Test with password
        {
            hash<auto> request = {
                "entries": (
                    {"name": "secret.txt", "data": binary("Secret content")},
                ),
                "password": "TestPassword123",
            };

            hash<auto> response = dp.doRequest(request);
            assertEq(True, exists response.data, "encrypted response has data");

            # Verify it's encrypted
            ZipFile zip(response.data);
            hash<ZipEntryInfo> entry = zip.getEntry("secret.txt");
            assertEq(True, entry.is_encrypted, "entry is encrypted");
            zip.close();
        }
    }

    # ==================== Decompress Data Action Tests ====================

    decompressDataActionTest() {
        # Create test archive data
        binary archiveData;
        {
            ZipFile zip();
            zip.addText("decomp1.txt", "Decompress content 1");
            zip.addText("decomp2.txt", "Decompress content 2");
            zip.addText("decomp3.txt", "Decompress content 3");
            archiveData = zip.toData();
        }

        # Get the decompress data provider
        ZipDataProvider factory();
        AbstractDataProvider dp = factory.getChildProviderEx("data").getChildProviderEx("decompress");
        assertEq(True, exists dp, "decompress data provider exists");

        # Test decompressing all entries
        {
            hash<auto> request = {
                "data": archiveData,
            };

            hash<auto> response = dp.doRequest(request);
            assertEq(3, response.entry_count, "entry count is 3");
            assertEq(3, response.entries.size(), "entries hash has 3 items");
            assertEq("Decompress content 1", response.entries{"decomp1.txt"}.toString("UTF-8"), "content 1 matches");
            assertEq("Decompress content 2", response.entries{"decomp2.txt"}.toString("UTF-8"), "content 2 matches");
            assertEq("Decompress content 3", response.entries{"decomp3.txt"}.toString("UTF-8"), "content 3 matches");
        }

        # Test decompressing specific entries
        {
            hash<auto> request = {
                "data": archiveData,
                "entry_names": ("decomp1.txt", "decomp3.txt"),
            };

            hash<auto> response = dp.doRequest(request);
            assertEq(2, response.entry_count, "filtered entry count is 2");
            assertEq(True, exists response.entries{"decomp1.txt"}, "has decomp1.txt");
            assertEq(True, exists response.entries{"decomp3.txt"}, "has decomp3.txt");
            assertEq(False, exists response.entries{"decomp2.txt"}, "does not have decomp2.txt");
        }
    }
}
